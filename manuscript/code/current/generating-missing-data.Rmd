---
title: "generating-missing-data"
author: "Tony Ni"
date: "9/18/2020"
output: pdf_document
---

Playing around with how to make vectors and datasets with missing values...

Some websites/sources:
\itemize{begin}
  \item https://cran.r-project.org/web/packages/missMethods/vignettes/Generating-missing-values.html
  \item https://rmisstastic.netlify.app/how-to/generate/misssimul
\itemize{end}

```{r}
library(tidyverse)
library(missMethods) #package for generating missing data
```

Assuming normal distribution (refer to technotes pdf file) for contaminant values in groundwater data, I'm going to try to see what sort of mean and sd we should have for a random element (in this case Boron)

```{r}
antimony_illinois <- read_csv("code/current/data/long_illinois.csv") %>%
  filter(contaminant %in% "Antimony") %>%
  drop_na()

antimony_illinois <- antimony_illinois %>%
  mutate(log_concentration = log(concentration),
         mean_log = mean(log_concentration),
         sd_log = sd(log_concentration))
```

Ok let's just try to pull random numbers from a logNormal(-5.341781, 2.41328) distribution for a "artificial" dataset.

```{r}
set.seed(7271999)

num <- 100

id <- seq(1, num, by = 1)
value <- rlnorm(n = num, 
               meanlog = antimony_illinois$mean_log,
               sdlog = antimony_illinois$sd_log)

my_df <- as.data.frame(cbind(id, value))
```

Now, to play around with the methods in the `missMethods` package. These methods let us generate missing values in a dataset, in our case -- the artificial dataset we generated above.

```{r}
my_df2 <- delete_MAR_censoring(ds = my_df, #dataframe
                     p = 0.3, #probability that a value is missing
                     cols_mis = "id",
                     cols_ctrl = "value")
```

Uh... I don't think the methods in this package are what we're looking for... This `delete_MAR_censoring` "generate MAR values using a censoring mechanism. This leads to a missing value in `id`, if the value is below the 30% quantile of `value`" We really only have 1 numeric variable of interest here...

Maybe we can just do it by hand...

Let's just say something like, for any value below `some number`, we make a new column and mark it as being censored/below limit of detection. I just chose 0.005 as a completely arbitrary value...

```{r}
threshold <- 0.005

my_df3 <- my_df %>%
  mutate(below_detection = case_when(value <= threshold ~ "T",
                                     value > threshold ~ "F"))
```

Now let's try visualizing the artificial dataset we just generated:

```{r}
#unsure what sort of plot might even be useful here lol
```









