---
title: "simulation-study"
author: "Tony Ni"
date: "1/20/2021"
output: pdf_document
---

```{r}
library(tidyverse)
library(Metrics) #package to help calculate mse
library(NADA) #package with implementation of many methods
```


First, a function to help us generate our desired dataset, where users can specify the mean, sd, sample size (of each run), and censoring rate:

```{r, echo = FALSE}
#function will generate a vector of numbers from the lognormal distribution and censor them at the given rate
#function will take in arguments for 1) samplesize, 2) logmean, 3)logsd
#what column names do we need to run all our methods? --> true.value (numeric), below (boolean)

generateData <- function(sampsize, m, s, censrate){
  true.value <- rlnorm(sampsize, 
               meanlog=log(m^2 / sqrt(s^2 + m^2)),
               sdlog=sqrt(log(1 + (s^2 / m^2))))
  
  uncensored_df <- as.data.frame(true.value) %>%
    arrange(true.value)
  
  censored_df <- uncensored_df %>% #take the head(%) of data to be censored
    slice_head(n=nrow(uncensored_df)*censrate) %>%
    mutate(censored = TRUE)
  
  #full join original df and sliced df
  return_df <- full_join(uncensored_df, censored_df, by = "true.value")

  #replace NAs with FALSE
  return_df$censored <- replace_na(return_df$censored, replace = FALSE)
  
  return(return_df)
}
```

```{r, echo = FALSE}
#helper function to round numbers in df

round_df <- function(df, digits){
  num_columns <- sapply(df, mode) == "numeric"
  df[num_columns] <- round(df[num_columns], digits)
  return(df)
}

```


What do we want our code to do? 

We first need to generate simulated data sets with the following combinations of censoring rates and sample sizes: (censoring rates: 10, 30, 50, sample sizes: 10, 100, 1000)

For each censoring/sample size pair, we create a simulated dataset with those specifications and run the substitution method with a specified number of iterations (`iterations`). For each sample, we will obtain the true mean (when considering all values to be uncensored), the estimated mean (when considering the uncensored values and the imputed values), alongside the MSE of each dataset`       `

the average mse is ultimately what we are interested in

```{r, echo = FALSE}
options(scipen=999) #prevent scientific notation

set.seed(7271999)

iterations <- 5 #number of iterations
censvalues <- c(0.10, 0.30, 0.50)
sampsizes <- c(10, 100, 1000)
combinations <- paste(rep(censvalues, each = length(sampsizes)), sampsizes, sep = ", ") #list of all combinations of censvalues and sampsizes

df.final <- as.data.frame(combinations) #df to store all final results

sub.list.MSE <- c() #empty list to store MSE(s)
mle.list.MSE <- c()
km.list.MSE <- c()
ros.list.MSE <- c()

list.true.mean <- c()
list.sub.mean <- c()
list.mle.mean <- c()
list.km.mean <- c()
list.ros.mean <- c()

for(i in censvalues){
  for(j in sampsizes){
    for(k in 1:iterations){
      df <- generateData(sampsize = j, m = 1, s = 0.5, censrate = i)
      
      #substitution
      LOD <- min(df$true.value[df$censored == FALSE]) #define LOD to be smallest, uncensored value
      df <- df %>%
        mutate(impSubValue = if_else(censored == TRUE, LOD/2, true.value))
      list.true.mean[k] <- mean(df$true.value) #calculate true mean
      list.sub.mean[k] <- mean(df$impSubValue) #calculate est. mean (with substitution)
      
      #mle
      mle_res = cenmle(df$true.value, df$censored)
      list.mle.mean[k] <- mean(mle_res)[1]
      
      #km
      km_res = cenfit(df$true.value, df$censored)
      list.km.mean[k] <- mean(km_res)[[1]]
      
      #ros
      ros_res = ros(df$true.value, df$censored)
      list.ros.mean[k] <- mean(ros_res)
    }
    #end of # iterations
    sub.list.MSE <- append(sub.list.MSE, (mse(list.true.mean, list.sub.mean))) 
    mle.list.MSE <- append(mle.list.MSE, (mse(list.true.mean, list.mle.mean)))
    km.list.MSE <- append(km.list.MSE, (mse(list.true.mean, list.km.mean)))
    ros.list.MSE <- append(ros.list.MSE, (mse(list.true.mean, list.ros.mean)))
  }
}
df.final <- round_df(df.final, 7)
df.final <- as.data.frame(cbind(combinations, 
                                substitution = sub.list.MSE, 
                                mle = mle.list.MSE,
                                km = km.list.MSE,
                                ros = ros.list.MSE))

df.final <- df.final %>%
  mutate_at(c(2:5), as.numeric)
```

\newpage

```{r}
knitr::kable(df.final)
```

<!--

```{r, echo = FALSE}
# SPACE TO TEST BELOW

df <- generateData(sampsize = 100, m = 1, s = 0.5, censrate = 0.10)

LOD <- min(df$true.value[df$censored == FALSE]) #define LOD to be smallest, uncensored value

df <- df %>%
  mutate(impSubValue = if_else(censored == TRUE, LOD/2, true.value))

true.mean <- mean(df$true.value)
est.mean <- mean(df$impSubValue)

#playing around with putting data into a df
combinations <- cbind(combinations, substitution = sub.list.MSE)

test <- df.final %>%
  mutate_at(c(2:3), as.numeric)
```

-->



